//  Crypto-Obscured Forwarder
//
//  Copyright (C) 2017 NI Rui <nickriose@gmail.com>
//
//  This file is part of Crypto-Obscured Forwarder.
//
//  Crypto-Obscured Forwarder is free software: you can redistribute it
//  and/or modify it under the terms of the GNU General Public License
//  as published by the Free Software Foundation, either version 3 of
//  the License, or (at your option) any later version.
//
//  Crypto-Obscured Forwarder is distributed in the hope that it will be
//  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
//  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with Crypto-Obscured Forwarder. If not, see
//  <http://www.gnu.org/licenses/>.

package common

import (
	"errors"
	"net"
	"strconv"
	"sync"
)

// Address errors
var (
	ErrAddressResolvedButNoResult = errors.New(
		"The address has been resolved, but no result")
)

// Address repersents a host:port pair, the host part of which
// can be resolved and cached
type Address interface {
	Get() (string, error)
	TryRenew()
}

// address implements Address
type address struct {
	rawHost       string
	rawPort       uint16
	resolved      string
	resolveNeeded bool
	lock          sync.RWMutex
}

// NewAddress creates a new Address
func NewAddress(host string, port uint16) Address {
	return &address{
		rawHost:       host,
		rawPort:       port,
		resolved:      "",
		resolveNeeded: true,
		lock:          sync.RWMutex{},
	}
}

// getSolved gets resolved address cache
func (a *address) getResolved() string {
	a.lock.RLock()
	defer a.lock.RUnlock()

	if a.resolveNeeded {
		return ""
	}

	return a.resolved
}

// bumpBackRenew cancels the renew tag
func (a *address) unmarkRenew() {
	a.lock.Lock()
	defer a.lock.Unlock()

	a.resolveNeeded = false
}

// resolve convert host address to host IP and update resolve cache
func (a *address) resolve() (string, error) {
	// We unmark renew whether we renewed it or not.
	// because there are a lot of problem can cause a renew, for
	// example internet lost. In that case the IP address itself hasn't
	// been changed, but LookupIP function below will be failed.
	// If we force it to update until success, there will be a lot of
	// waste generated by doing that.
	defer a.unmarkRenew()

	addrs, err := net.LookupIP(a.rawHost)

	if err != nil {
		return "", err
	}

	if len(addrs) <= 0 {
		return "", ErrAddressResolvedButNoResult
	}

	a.lock.Lock()
	defer a.lock.Unlock()

	a.resolved = net.JoinHostPort(
		addrs[0].String(), strconv.FormatUint(uint64(a.rawPort), 10))

	return a.resolved, nil
}

// Get return resolved address in string
func (a *address) Get() (string, error) {
	var err error

	result := a.getResolved()

	if result != "" {
		return result, nil
	}

	result, err = a.resolve()

	if err != nil {
		return "", err
	}

	return result, nil
}

// TryRenew tells address to renew the address cache one time
// It's the users responsibility to recall the renew if previous
// one has failed
func (a *address) TryRenew() {
	a.lock.Lock()
	defer a.lock.Unlock()

	a.resolveNeeded = true
}
